---
code: QZ01
title: Unit 1 Quiz
date: 2026-02-11
type: lesson
threads: ["Course"]
authors: [Kris Jordan]
---

The goal of this page is to provide you with a single source of guidance on what to review and prepare for ahead of Quiz 1. The goal of the quiz is to assess your understanding of key concepts, ideas, and skills we have covered in the first two weeks of class.

## Task Learning Objectives

### From TK04 - Professionalizing the Developer Environment

1. What is a code formatter?
1. What is a linter?
1. What value does each uniquely provide to a software engineering team?
1. How do you extend your IDE (such as VSCode) to support developer tools like formatting and linting?
1. What is a static type checker?
1. Why is a static type checker useful in Python?
1. Why don't you need a separate tool for this in a language like Java?
1. Why is "ceremony" required to write a test in a testing framework?
1. What is _coverage_ in the context of automated testing?
1. What are fixtures and why are they important in testing?

### From TK05 - Unit and Integration Testing Exercise

After successfully completing this exercise, you should be able to:

1. Read and navigate a new codebase, understanding its structure and developer tooling.
1. Explain the value of test-driven development (TDD) and apply the Red → Green → Refactor cycle.
1. Write unit tests that verify individual components in isolation.
1. Use mocks to isolate the subject under test from its composed dependencies.
1. Use patches to intercept built-in library calls and test logic without side effects.
1. Write integration tests that verify components work together with real dependencies.

These skills are foundational to the upcoming quiz and will be assessed in the context of your work on this task.

## Lesson Learning Objectives

### From LS05 - Designing with Layers and Composition

After lecture, you should be able to address:

1. What is a strict layered architecture?
2. What are common motivations and trade-offs in layered systems?
    * Separation of Concerns
    * Clear interfaces and contracts
    * Dependency direction
    * Replaceability
    * Maintainability
    * Testability
3. The role object-oriented _composition_ plays in layered software architectures.
4. The role of Fake implementations via subclassing or interfaces and trade-offs.

### From LS06 - AAA (Arrange, Act, Assert) Testing and Mocking

After lecture, you should be able to address:

1. What do the steps of Arrange, Act, and Assert mean in practice? Why is it a valuable test design pattern?
2. What is a _test double_? How is a _Mock_ different from a _Fake_?
3. What are some fundamental facilities of a _MagicMock_ that support automated testing?

### From LS07 - Testing with Patching and Fixtures

After lecture, you should be able to address:

1. What is _patching_? When is it necessary? How does it relate to test doubles (fakes, mocks)?
2. What is the utility of a _fixture_ as it relates to automated testing?

### From LS08 - Patching and Testing Practice

After lecture, you should be able to address:

1. How do fixtures factor into the lifecycle of running one test? Multiple tests?
2. When patching a name in a dynamic language like Python, why must you patch the name _where it is used_ in Python and not where it is _defined_?

## From LS09 - Models and Data Vadidation

After lecture, you should be able to address:

1. What is a data model?
2. What is data validation? Why is it important?
3. What is the difference between _declarative_ style programming vs. _imperative_? How is this exemplified in a data modeling library like Pydantic?

## From RD13 - How AI Impacts Skill Formation

After reading, you should be able to address:

1. What is a danger in over-reliance on AI generated code when learning new concepts?
2. Why did _conceptual inquiry_, _hybrid code-explanation_, and _generation-then-comprehension_ techniques seem to improve quiz scores over the other AI-involved methods?